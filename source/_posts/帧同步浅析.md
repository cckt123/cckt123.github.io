---
title: 帧同步浅析
date: 2022-06-25 17:03:00
tags: [ Unity]
categories: [ Unity]
about:
description: "帧同步学习笔记。"
password: Xm4399
---

## 前言

之后可能要摸相关的内容，所以来看看帧同步。

## 什么是帧同步？

同步，指多个客户端表现一致。当在一个客户端进行某项操作的同时，在其他客户端也会观测到相同的结果。不仅需要在客户端保持一致，在服务端的数据也需要是一致的。因而同步是一个网络游戏的名词，单机游戏并不需要同步。

现有的同步方案中，分为帧同步与状态同步，实际的项目中会依据两者特性结合使用。

帧同步大部分游戏逻辑都在客户端上实现，服务器主要负责广播和验证操作。**帧同步通过同步玩家的操作，保证所有人在每一帧上都获得相同的输入，执行相同的逻辑，最后得到一致的表现和结果。这里面包含两个同步，一个是时间同步，一个是指令同步。** 即客户端在相同的时间获得相同的指令，而后表现出相同的效果。

客户端的指令上传到服务器，服务器依据当前帧间隔内收集到的操作指令广播给每一个客户端，各个客户端在一致的环境下进行操作的处理。

![帧同步逻辑](https://img-blog.csdnimg.cn/20200627161315551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjExNTUz,size_16,color_FFFFFF,t_70#pic_center)

## 什么是状态同步？

状态同步对网络延迟的要求不高，允许出现多客户端表现不一致，只要结果一致。逻辑由服务器实现，数据量较大，安全性高。客户端发送操作到服务器，服务器计算出结果后，将结果以广播的方式返回给客户端。

## Unity使用帧同步需要注意什么？

帧同步的逻辑建立在 SameInput + SameTime = SameOutput 之上，即输入指令和输入时间一致，那么会产生 **必然一致** 的结果。

Unity在使用的过程中，这点是关注的核心。为满足上述要求

+ Unity内的浮点数精度应一致，或不使用浮点数。
+ 协议数据顺序一致
+ 客户端、服务器的处理逻辑一致
+ 具有确定性的物理引擎/避免使用Unity自带的物理引擎
+ 渲染相关的函数，如Awake()、Start()、Update()、LateUpdate()、OnDestroy()等，不应该参与游戏逻辑的判断
+ 禁用Time类相关属性及函数，如Time.deltaTime等。
+ 避免使用协程Coroutine

## 帧同步实现的细节？

帧同步核心逻辑实现包含两个部分

1. 命令队列的设计
2. 游戏的主循环实现

### 命令队列

命令队列抽象了命令这个概念，当玩家执行操作之后，会有一条具备当前操作信息的命令产生。如果当前为单机模式，那么条命令会直接加入到队列中，如果是网络，那么他会将这条命令上传到服务器，通过服务器的命令设置再将其填入到队列中执行。

这种模式下，单机模式和网络模式代码基本一致，表现差异在于创建了不同的监听器，而这种队列设计很容易实现回放和观战。

就像是设计模式-命令模式的实际应用。

### 主循环

一般游戏的主循环就是Update，但是参照上述的注意事项，我们为了确保结果的一致性，需要将游戏的执行顺序严格的把握在手上，因而不能使用Update，需要我们主动去控制帧率。

帧率控制有两件事。

1. 按照特定的频率去运行游戏，控制游戏的逻辑帧率。
2. 控制追帧，当前玩家游戏进度落后，应该加快逻辑帧数，前进更多的逻辑帧以保证一致。

## 逻辑与渲染？

上述内容提到过主动控制逻辑帧率的问题。这里需要引入一个新的概念，逻辑帧与渲染帧。

当主动接管循环控制之后，为保证游戏渲染流畅，将渲染与逻辑分离，拆分成逻辑帧与渲染帧。

逻辑帧负责处理与服务器交互的数据，用于同步各个客户端。比如玩家的移动，技能释放等等。

客户端帧，这是一个逻辑帧的补充部分，为了应对游戏的精度判断要求，以防止游戏逻辑帧间隔过长，而导致的问题。客户端依据客户端帧来计算逻辑，在这里进行逻辑判断，而逻辑帧用于数据的上传分发。客户端帧和逻辑帧严格对应，有序，一般是逻辑帧的整数倍。

如果逻辑帧可以满足游戏逻辑的运算需求，那么可不必要有客户端帧。

渲染帧，这里不参与任何逻辑运算，用于保证客户端渲染的流畅性，同时逻辑解耦，分摊CPU压力。

## 网络延迟？

网卡了，这种是没办法的事情。这种情况会导致网络延迟，客户端表现不一致。

上述提到了渲染与逻辑层分离也有助于对抗网络延迟导致的渲染抖动。但是还不够。

为弥补这个问题，可以通过增加帧缓冲和前摇动画的方式去掩盖延迟。

其次，可在底层使用UDP替换TCP。

再然后，如果发生大量延迟怎么办呢？

**为了保证结果一致，通用的做法就是卡住（锁帧同步）**。如果这一帧的数据没有下来，就卡住等这一帧的数据下来，之后加速追回到当前的进度。

还有另一种做法，预测回滚。客户端没有操作的情况下，服务器不下发空包，有操作的情况下下发。因而如果当客户端没有收到包，也会继续执行，但如果收到包延迟，那么

**这时候客户端的状态会出错，然后我们需要进行纠错。**

## 战斗框架设计？

整个战斗框架设计的核心是使用组件设计，把显示层和逻辑层进行分离。和上述提到内存差不多，将其分离之后有助于逻辑层的序列化与反序列化，在服务端运行，检测外挂，校验安全性。

## 参考文献

+ [帧同步](https://zhuanlan.zhihu.com/p/399803254)
+ [帧同步](https://blog.csdn.net/qq2512667/article/details/89918113)
+ [干货！光子高级工程师揭秘帧同步游戏的技术实现细节](https://baijiahao.baidu.com/s?id=1710208669164763724&wfr=spider&for=pc)
+ [游戏同步方案——帧同步](https://blog.csdn.net/qq_41211553/article/details/106983481)

