---
title: 状态压缩
date: 2021-10-17 20:38:28
tags: [算法, 状态压缩, 算法]
categories: [ 算法]
about:
---
# 状态压缩
这篇文章源于[5904.统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)

因为我不会写，所以我翻了题解，找了答案，然后遇到了一个崭新的名词解释。

那么

+ ### 什么是状态压缩？
  
  状态压缩，顾名思义，实质上是对对象状态表达的数据量进行压缩表达。

  举例而言，假设这里有一扇门，它有开门，关门两种状态，分别使用1和0表示。这就是状态压缩。

  开门->1

  关门->0

  当我们执行开门动作时，0+1=1，门开了。
  
  反之，当我们执行关门动作时，1-1=0，门关了。

  上述的例子从一个复杂的表达状态转换成了一个1和0的问题。但是状态压缩的能力却不止于此，01二进制用来可以表达的信息量巨大。
  
  比如Int类型32位，每个数代表一种状态，就可以表达上亿种状态，虽然实质上我们并不需要这么多。

  状态压缩适用于数据量大，但每个构成个体相对简单的情况。


+ ### [优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)
  于是，1+1=2，你懂了，我也懂了，现在让我们来解一下这个不定积分问题吧！
```C++
//这篇题解来自于LeetCode官方，从上面链接可以跳转
class Solution {
public:
    int countArrangement(int n) {
        vector<int> f(1 << n);
        f[0] = 1;
        for (int mask = 1; mask < (1 << n); mask++) {
            int num = __builtin_popcount(mask);
            for (int i = 0; i < n; i++) {
                if (mask & (1 << i) && (num % (i + 1) == 0 || (i + 1) % num == 0)) {
                    f[mask] += f[mask ^ (1 << i)];
                }
            }
        }
        return f[(1 << n) - 1];
    }
};

  __builtin_popcount();
  //用于计算32位无符号整数有多个位为一的个数
  //实际原理是使用表来进行位搜索，效率很高
  //举例而言 5 = 101 有2个1
  //__builtin_popcount(5)=2;
```
  依照上述的定义，我们使用一个二进制数来表示一种状态。
  
  举例而言，101代表使用取用第1个和第3个数字。

  每次取或不取有两种可能性，因而当长度为n，就有2^n种的可能，二进制计算这个值非常便利，只要将1向左移动n位即可。

```C++
    vector<int> f(1 << n);
    f[0] = 1;
    //f[i]代表n=i时可行方案数

    for (int mask = 1; mask < (1 << n); mask++) {
        //此处略去中间内容
        //这里的mask就是暴力枚举1~2^n中所有的可能性
    }
```

  __builtin_popcount();的作用不再赘述。 

```C++
    for (int i = 0; i < n; i++) {
        /*
        mask的含义已知为当前枚举的选择可能
        mask & (1 << i)为1 代表已经选出当前的第i个数
        
        (num % (i + 1) == 0 || (i + 1) % num == 0)
        还记得题目要求的条件吗？
        perm[i] 能够被 i 整除
        i 能够被 perm[i] 整除
        称之为美丽数列i从0开始，i+1返还，表示从1开始的第i个数。
        num表示在perm中的位数 转换回去就是第最后一个perm[perm.Length-1]
        */
        if (mask & (1 << i) && (num % (i + 1) == 0 || (i + 1) % num == 0)) {
             f[mask] += f[mask ^ (1 << i)];
        }
        //f[mask] = f[mask](当前最高位可以放入的数量)+除去当前最高位放入数字数量的和
        //dp
        //举例而言 
        //当前选取 101 最高位放入100 则剩下的部分就是001
    }
```

