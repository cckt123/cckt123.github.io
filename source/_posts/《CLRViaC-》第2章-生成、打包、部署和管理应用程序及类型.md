---
title: 《CLRViaC#》第2章 生成、打包、部署和管理应用程序及类型
date: 2022-02-14 16:26:03
tags: [ C#, CLR]
categories: [ C#]
about:
description: "阅读笔记与总结，这本书的深度远高于我的理解范畴，因而笔记不免有所遗漏，如果有缺漏之处请查看原书。"
---

## 2.1 .NET Framework 部署目标

1. **DLL hell** 避免对已安装的应用程序造成影响。
2. 安装的复杂性，大多数应用程序在安装时影响系统的全部组件。在备份，移除应用程序的时候不避免的有所遗漏，避免这个问题。
3. 安全性，用户必须自己能够决定赋予应用哪些权限。

## 2.2 将类型生成到模块之中

本节讨论如何将包含多类型的源码转变为可部署的文件。

### 2.2.1 CSC.exe 命令执行

这里默认已安装.NetForamwork框架。

![cscimage](/images/cscimage.png)

找到指定位置下的csc.exe，然后将其添加到环境变量之中。

详细内容请参照[csc.exe的使用总结与例子](https://blog.csdn.net/qq_36090938/article/details/100513156)。

### 2.2.2 执行流程

``` csharp
using System;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("HelloWorld!");
        }
    }
}
```

举例而言，该应用程序定义了Program类，然后

Program->Main->public static->System.Console->IL->MSCorLib.dll

System.Console是微软实现好的类，它的IL代码存储在MSCorLib.dll之中。

 ```sh
  csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs
 ```

可以在命令行执行该命令来编译上述文件，最后生成Program.exe。值得注意的是，**csc编译仅支持C#5之前的版本，之后的版本将不再支持**。

![warn](/images/cscwarn.png)

但总之，MSCorLib.dll是特殊文件，包含了所有核心类型，包括**Byte、Char、String、Int32**等。事实上会默认将其设置为引用，也就是/r[reference]。所以上图测试的时候可以不添加额外的命令。/out:Program.exe /t:exe同理。

在上述实例代码中，源代码之中并没有System.Console的实现，因而C#编译器会自动寻找相关的引用来处理他。

最后生成的.exe文件是标准的PE(可移植执行体，Portable Executable)文件，可在32/64位系统上运行。可参照[上一篇笔记](https://crazyink47.xyz/2022/02/10/%E3%80%8ACLRViaC-%E3%80%8B%E7%AC%AC1%E7%AB%A0-CLR%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/#1-3-%E5%8A%A0%E8%BD%BD%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6)来获取详细信息。

Windows支持三种程序

1. 生成控制台用户界面GUI /t:exe
2. 生成图形用户界面GUI /t:winexe
3. WindowsStore /t:appcontainerexe

### 2.2.3 响应文件

响应文件用于将繁杂的开关命令记录，在调用时自动传递给csc。

举例而言 

``` shell
MyProject.rsp
/out:MyProject.exe
/target:winexe
```

可使用如下命令调用他

``` shell
csc.exe @MyProject.rsp CodeFile1 CodeFile2
```

因为csc可能已经被新的技术栈替换，所以这里暂时不做更多研究，如果需要请查看原书。

## 2.3 元数据概述

Program.cs文件里究竟有什么呢？

托管PE文件由四部分组成

1. PE32(+)头 Windows要求的标准信息
2. CLR头 CLR模块特有，含有面向CLR的major、minor版本号，flag，MethodDef token，可选的强名称数字签名，元数据表大小与偏移。
3. 元数据 
4. IL

而元数据是由几个表形成的二进制数据块。

1. 定义表 definition table
2. 引用表 reference table
3. 清点表 manifest table

常见定义表

| 元数据定义表名称 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| ModuleDef        | 总是包含对模块进行表示的一个记录项。该记录项包含模块文件名和拓展名，以及模块版本ID。这样可在保留原始名称的前提下自由重命名文件。但不建议重命名文件，可能会妨碍CLR运行时正确定位程序集。 |
| TypeDef          | 模块定义的每个类型在这个表中都有一个记录项。每个记录项都包含类型的名称，基类型、一些标志以及一些索引，这些索引指向MethodDef表中该类型的方法、FieldDef表中该类型的字段、PropertyDef表中该类型的属性以及EventDef表中该类型的事件。 |
| MethodDef        | 模块定义的每个方法在这个表中都有一个记录项。每个记录项都包含类型的名称、基类型、一些标志、签名以及方法的IL代码在模块中的偏移量。每个记录项还引用了ParamDef表中的一个记录项，后者包括与方法参数有关的更多信息。 |
| FieldDef         | 模块定义的每个字段在这个表中都有一个记录项。每个记录项都包含标志、类型和名称。 |
| ParamDef         | 模块定义的每个参数在这个表之中都有一个记录项。每个记录项都包含标志、类型和名称。 |
| PropertyDef      | 模块定义的每个属性在这个表之中都有一个记录项。每个记录项都包含标志、类型和名称。 |
| EventDef         | 模块定义的每个事件在这个表之中都有一个记录项。每个记录项都包含标志、类型和名称。 |

常见引用表

| 引用元数据表名称 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| AssemblyRef      | 模块引用的每个程序集在这个表中都有一个记录项。每个记录项都包含绑定该程序集所需的信息:程序集名称、版本号、语言文化，公钥，标志和哈希值。 |
| ModuleRef        | 实现该模块所引用的类型的每个PE模块在这个表中都有一个记录项。每个记录项都包含模块的文件名和拓展名。可能是别的模块实现了你需要的类型，这个表的作用便是建立同那些类型的绑定关系。 |
| TypeRef          | 模块引用的每个类型在这个表中都有一个记录项。每个记录项都包含类型的名称和一个引用。如果类型在另一类型之中实现，引用指向一个TypeRef记录项。如果类型在同一模块之中实现，引用指向一个ModuleDef记录项。如果类型在调用程序集内的另一模块中实现，引用指向一个ModuleRef记录项。如果类型在不同的程序集中实现，引用指向一个AssemblyRef记录项。 |
| MemberRef        | 模块引用的每个成员在这个表中都有一个记录项。每个记录项都包含成员的名称和签名，并指向对成员进行定义的那个类型的TypeRef记录项。 |

可以使用多种反编译工具查看托管PE文件之中的元数据。原作者给出了ILDasm.exe的应用

``` sh
ILDasm Program.exe
```

然而我这里暂时因为某些特殊原因无法使用反编译工具。所以我也没有验证过这个。这部分内容更多是教授如何查看IL源码，以及梗概的内容介绍，原作者给出的反编译之后的结果需要更多的知识作为铺垫才能理解，上述的介绍暂时看看就好。

## 2.4 将模块合并成为程序集

Program.exe并非仅包含元数据的PE文件，他还是 **程序集(assembly)** 。程序集是一个或者多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了 **清单(manifest)** 。也就是上一部分介绍中的第三项清单表。表中包含程序集作为组成部分的文件名称，程序集版本、语言文化、发布者、公开导入的类型和构成程序集的所有文件。

CLR操作的是程序集。换而言之，CLR总是首先加载包含“清单”元数据表的文件，在根据“清单”来获取程序集中的其他文件的名称。

+ 程序集定义了可重用的类型
+ 程序集用一个版本号标记
+ 程序集可以关联安全信息

类型为了顺利打包，版本控制，安全保护以及使用，必须放在程序集一部分的模块之中。程序集大多数时候只有一个文件，但这并不表示他只可以有一个文件。他可以由多个文件构成，一部分是含有元数据的PE文件，另一些是.gif或者.jpg。

程序集将可用类型的逻辑与物理表示分开，将常用类型放到一个文件之中，不常用类型放到另一个文件之中。如果程序集要从Internet下载并部署，那对于不常用的类型，如果客户端不需要，那么就永远不会被下载。

可在应用程序配置文件中的指定codeBase元素，定义URL指向位置，找到程序集所有的文件。详见第三章。

多文件程序集的优势

+ 不同类型不同文件，需要时增量下载
+ 可在程序集中添加任意类型的数据文件
+ 程序集之中包含的各个类型可以由多种不同的程序语言来完成

生成程序集要么选择现有的PE文件作为"清单"的宿主，要么创建单独的PE文件并只在其中包含清单。

| 清单元数据表名称    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| AssemblyDef         | 如果模块标识的是程序集，这个元数据表就包含单一记录项来列出程序集名称、版本、语言文化、哈希算法和公钥。 |
| FileDef             | 作为程序集的一部分的每个PE文件和资源文件在这个表中都有一个记录项(清单本身所在的文件除外，该文件在AssemblyDef表的单一项中列出)。在每个记录项中，都包含文件名和拓展名、哈希值和一些标志（flags）。如果程序集值只包含它自己的文件，FileDef表将无记录。 |
| ManifestResourceDef | 作为程序集一部分的每个资源在这个表中都有一个记录项。记录项中包含资源名称、一些标志以及FileDef表的一个索引。如果资源不是独立文件，那么资源就是包含在PE文件中的流。对于嵌入资源，记录项还包含一个偏移量，指出资源流在PE文件中的起始位置。 |
| Ex[prtedTypesDef    | 从程序集中的素有的PE模块中到处的public类型在这个表中都有一个记录项。记录项中包含类型名称、FileDef表的一个索引，以及TypeDef表的一个索引。注意，为了节省空间，从清单所在文件导出的类型不再重复，因为可以通过元数据的TypeDef表获取类型信息。 |

由于清单的存在，程序集用户不必关系程序集的划分细节。另外，清单也使程序集具有了自描述性。

### 2.4.1 使用VS将程序集添加到项目之中

![Reference](/images/ReferenceShow.png)

解决方案资源管理器，右键项目，添加引用。

### 2.4.2 使用程序集链接器

还可以使用AL.exe来创建程序集。如果程序集要包含有不同编译器生成的模块，或者在生成是不清楚程序集的打包要求。程序集链接器就会派上用场。还可以使用AL.exe生成只含资源的程序集，也就是所谓的附属**附属程序集**。他们通常用于本地化。

### 2.4.3 为程序集添加资源文件

使用AL.exe创建程序集时，可用/embed[resource]开关将文件作为资源添加到程序集，将文件内容嵌入最终的PE文件。清单的ManifestResourceDe会更新记录新资源的存在。

AL.exe 支持/link[resource]开关，同样获取包含资源的文件，但是只会更新清单的ManifestResourceDef和FileDef表以反映新资源的存在，指出资源包含在程序集的哪个文件之中。资源文件不会嵌入程序集PE当中。

## 2.5 程序集版本资源信息

AL.exe或CSC.exe生成PE文件程序集时，还会在PE文件中嵌入标准的Win32版本资源。可查看文件属性来查看该资源。在应用程序之中调用**System.Diagnostics.FileVersionInfo**的静态方法**GetVersionInfo** ，并传递程序集路径作为参数，就可以获取并检查这些信息。

生成程序集时，应该使用定制的特性设置各种版本资源字段，这些特性在源代码中应用于assembly级别。

``` csharp
using System.Refection;
//FileDescription版本信息
[assembly:AssemblyTitle("MultiFileLibrary.dll")]

//Comments版本信息
[assembly:AssemblyDescription("This assembly contains MultiFileLibrary's types")]

//CompanyName版本信息
[assembly:AssemblyCompany("Wintellect")]

//ProductName版本信息
[assembly:AssemblyProduct("~")]

//同理可得，需要的时候再查吧，我写完这个估计也忘了
```

### 2.5.1 版本号

程序集可以应用多个版本号，所有的版本号拥有相同的格式。

|      | major主版本号 | minor次版本号 | build内部版本号 | revision修订号 |
| ---- | ------------- | ------------- | --------------- | -------------- |
| 示例 | 2             | 5             | 719             | 2              |

前两个编号构成公众对版本的理解，第三个版本号是公司内部使用的迭代版本，修订版本号用于记录重新生成的同一程序集，常见于Bug修复。

+ AssemblyFileVersion

  这个版本号存储在Win32版本资源中，仅供参考，CLR不检查，不关心。

+ AssembluInformationalVersion

  这个版本号存储在Win32版本资源中，仅供参考，CLR不检查，不关心。

+ AssemblyVersion

  这个版本号存储在AssemblyDef清单元数据表当中，CLR在绑定到强命名程序集时会使用到他。他唯一标识了程序集。在开发程序集是设置好这个版本号之后不应该发生变动，除非要开发他的下一个版本。如果程序集A应用了强命名程序集B，程序集B的版本会嵌入程序集A的AssemblyRef表。当需要加载B的时候就会知道要加载那个指定版本的B。

## 2.6 语言文化

这个翻译不是很贴切，应该是指使用者语种。某些程序集会依据用户语系进行二次划分。

| 主标记 | 副标记 | 语言文化   |
| ------ | ------ | ---------- |
| de     |        | 德语       |
| de     | AT     | 奥地利德语 |
| de     | CH     | 瑞士德语   |
| en     |        | 英语       |
| en     | GB     | 英国英语   |
| en     | US     | 美国英语   |

虽然有这个标记，但是也可以不用，创建含有代码的程序集时一般不指定具体的语言文化。毕竟代码。未指定具体语言文化的程序集成为**语言文化中性**。标记了语言文化的程序集称之为**附属程序集**。

## 2.7 简单应用程序部署/私有部署的程序集

这里分两种情况

1. 第一种是用于WindowsStore的程序集，VS会将所有必要的程序集打包成.appx文件。文件需要上传到WindowsStore，或者side-load到机器....
2. 非WindowsStore桌面应用相对简单，没有特殊要求，最简单的打包方式就是复制所有文件。当然，也有其他打包方式，这里可以查看原书或者自行研究...

在应用程序基目录或者子目录部署的程序集称为**私有部署的程序集**，程序集文件不与其他任何应用程序共享。

## 2.8 简单管理控制

为了实现对应用程序的控制与管理，可在应用程序目录放入一个配置文件，默认会存放于应用程序基目录。配置文件包含XML代码，它既能与机器关联，也可以与程序关联。他可以用于追踪程序集的位置。

+ 对于可执行程序exe，配置文件必须在应用程序的基目录，必须采用exe文件全名作为文件名，附加.config拓展名。
+ 对于Microsoft ASP.NET Web窗体应用程序，文件必须在Web应用程序的虚拟根目录中，命名为Web.config。

## 额外参考资料

+ [csc.exe的使用总结与例子](https://blog.csdn.net/qq_36090938/article/details/100513156)
