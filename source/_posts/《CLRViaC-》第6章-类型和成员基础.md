---
title: 《CLRViaC#》第6章 类型和成员基础
date: 2022-02-21 10:01:48
tags: [ C#, CLR]
categories: [ C#]
about:
description: "阅读笔记与总结，这本书的深度远高于我的理解范畴，因而笔记不免有所遗漏，如果有缺漏之处请查看原书。"
---

## 6.1 类型的各类成员

类型之中可以定义任意个以下成员

+ 常量
+ 字段 建议将字段设置为私有防止被类型外部代码破坏
+ 实例构造器
+ 类型构造器
+ 方法
+ 操作符重载 值得注意的是 并不是所有编程语言都支持重载 因而CLS并不包含操作符重载
+ 转换操作符 同上
+ 属性
+ 事件
+ 类型

CLR为每一种CLR支持的语言转换上述的每一位成员将其转换成为元数据与IL代码。所有编程语言生成的元数据格式完全一致。因而可以用一种语言书写的代码访问另一种语言。

## 6.2 类型的可见性

public 所有程序集中所有类型可见

internal 当前程序集中所有类型可见 C#会默认使用该类型定义类型

### 友元程序集

彼此之间可以相互访问，但其他程序集不可以访问的类型。

生成程序集时，可以用System.Runtime.CompilerServices命名空间中的InternalsVisibleTo特性标明他认为是"友元"的程序集。这个特性获取标识友元程序集名称和公钥的字符串参数。注意 C#编译器在编译友元程序集时要求编译器开关**/out:\<file>**。同样，如果使用C#编译器的**/t:module**开关来编译模块，而且该模块将会成为某个友元程序集的一部分，那么还需要使用C#编译器的**/noduleassemvkyname:\<string>**开关来编译此模块。

## 6.3 成员的可访问性

| CLR术语             | C#术语             | 描述                                                         |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| Private             | private            | 成员只能由定义类型或任何嵌套类型中的方法访问                 |
| Family              | protected          | 成员只能由定义类型、任何嵌套类型或者不管在什么程序集中的派生类型中的方法访问。 |
| Family and Assembly | 不支持             | 成员只能由定义类型、任何嵌套类型或者同一程序集中定义的任何派生类型中的方法访问。 |
| Assembly            | internal           | 成员只能由定义程序集中的方法访问。                           |
| Family or Assembly  | protected internal | 成员可由任何嵌套类型、任何派生类型或者定义程序集中的任何方法访问。 |
| Public              | public             | 成员可由任何程序集的任何方法访问                             |

在C#中，如果没有显式声明成员的可访问性，编译器通常默认选择private。CLR要求接口类型的所有成员都具有public可访问性。C#编译器知道这一点，因而禁止开发人员显式指定接口成员的可访问性，编译器自动将所有成员的可访问性设为public。

## 6.4 静态类

C#之中，static关键字定义不可实例化的类。该关键字只能应用于类，不能应用于结构。因为CLR总是允许值类型实例化。C#编译器对静态类进行了如下限制。

+ 静态类必须直接从基类System.Object派生，从其他任何基类派生都没有意义。继承只适用于对象，而你不能创建对象的实例。
+ 静态类不能实现任何接口，这是因为只有使用类的实例时，才可调用接口方法。
+ 静态类只能定义静态成员，任何实例成员都会导致编译器报错。
+ 静态类不能作为字段、方法参数或局部变量使用，因为它们都代表引用了实例的变量，而这是不允许的。

## 6.5 分部类、结构和接口

partial关键字告诉C#编译器:类、结构或接口的定义源代码可能要分散到一个或者多个源代码文件当中。

+ 源代码控制

  将源代码分散到多个文件之中，以供多个程序员同时进行编辑。

+ 在同一个文件中将类或结构分解成不同的逻辑单元

+ 代码拆分

  防止不小心误编辑。

编译器会自动将这些代码合并，CLR对此一无所知。

## 6.6 组件，多态和版本控制

**组件软件编程(Component Software Programming,CSP)**正是OOP发展到极致的成功。

+ 组件(.NET Framwork称为程序集)有"已经发布"的意思。
+ 组件有自己的标识(名称、版本、语言文化和公钥)
+ 组件永远维持自己的标识(程序集中的代码永远不会静态连接到另一个程序集当中，.NET永远是动态链接)
+ 组件清楚指明它所依赖的组件(引用元数据表)
+ 组件应编档它的类和成员。C#语言通过源代码内的XML文档和编译器的/doc命令行开关来提供该功能。
+ 组件必须指定他需要的安全权限。CLR的代码访问安全性机制提供这个功能。
+ 组件要发布在任何"维护版本"中都不会改变的接口。

上述最后一点，为了支持在后续的版本管理，而防止新版本更迭导致原有的逻辑崩坏，C#为了提供了影响组件版本控制的关键字，可将他们应用于类型或者类型成员。

| C#关键字 | 类型                     | 方法/属性/事件                                               | 常量/字段 |
| -------- | ------------------------ | ------------------------------------------------------------ | --------- |
| abstract | 表示不能构造该类的实例   | 表示为了构造派生类型的实例，派生类型必须重写并实现这个成员   | 不允许    |
| virtual  | 不允许                   | 表示这个成员可由派生类型重写                                 | 不允许    |
| override | 不允许                   | 表示派生类型正在重写基类型的成员                             | 不允许    |
| sealed   | 表示该类型不能用作基类型 | 表示这个成员不能被派生类型重写，只能将该关键字应用于重写虚方法的方法 | 不允许    |
| new      | -                        | 应用于嵌套类型、方法、属性、事件或字段时，表示该方法与基类中相似的成员无关 | -         |

### 6.6.1 CLR如何调用虚方法、属性和事件

CLR提供两个方法来调用指令//这东西挺复杂的，建议查看原书，如果你只使用C#也可以略过这一小节

+ call 

  该IL指令可调用静态方法，实例方法和虚方法。用call指令调用静态方法，必须指定方法的定义类型。调用实例方法和虚方法，必须指定引用了对象的变量。call指令假定该变量不为null。如果变量的定义没有定义该方法，就检查基类型来查找匹配方法。Cell指令经常用于以非虚方式调用虚方法。

+ callvirt

  该IL指令可调用实例方法和虚方法，不能调用静态方法。用callvirt指令调用实例方法和虚方法，必须指定引用了对象的变量。用其调用非虚实例方法，变量的类型指明了方法的定义类型。用callvirt指令调用虚实例方法，CLR调查发出调用的对象的实际类型，然后以多态方式调用方法。为了确定类型，发出调用的变量绝不能是null。因而会进行额外的检测来确定是否为null。

将方法定义为非虚方法后，将来永远都不要把它更改为虚方法。这是因为某些编译器会用call而不是callvirt调用虚方法。如果方法从非虚变成虚，而引用代码没有编译，会以非虚方法调用虚方法，而结果无法预料。C#编写的代码不会出现这个问题，因为C#以callvirt指令调用所有实例方法。

设计类型时应尽量减少虚方法数量。首先，调用虚方法的速度慢于非虚方法，其次JIT编译器不能内嵌虚方法，第三，虚方法使组件版本控制变得更加脆弱，第四，定义基类型时，经常要提供一组重载的简便办法。如果希望这些方法是虚方法，使所有重载的简便方法成为非虚方法。

### 6.6.2 合理使用类型的可见性和成员的可访问性

定义新类型时编译器应默认生成密封类，使它不能作为基类使用。但许多包括C#的编译器都默认生成非密封类，只是允许开发人员使用关键字sealed将类显式标记为密封。

+ 版本控制

  如果类最初密封，将来可在不破坏兼容性的前提下更改为非密封。但如果最初是非密封，后来则不可以改为密封，因为将会中断派生类。另外，如果非密封类定义了非密封虚方法，必须在新版本的类中保持虚方法调用顺序，否则可能中断派生类。

+ 性能

  注意，如果JIT编译器看到使用密封类型的虚方法调用，就可采用非虚方式调用虚方法，从而生成更高效的代码。因为密封类不会有派生类。

+ 安全性和可预测性

  保证不会其他意外发生更改导致的逻辑错误。

密封类的问题是会给类型的用户带来不便，有时候开发人员需要继承下来原有的逻辑并附加辅助方法。因而

+ 定义类时，除非确定要将其作为类，并允许派生类对其进行特化，否则总是显式地指定为sealed类。
+ 类的内部，尽可能将所有字段定义为private。
+ 在类的内部，将自己的方法、属性、事件定义为private和非虚。
+ 在辅助类型之中使用辅助参数。

### 6.6.3 对类型进行版本控制时的虚方法处理

有些版本控制问题会导致代码兼容性问题，举例而言，如果类型要作为基类型使用，那么增加或者修改他的成员时务必非常小心。

``` csharp
namespace CompanyA
{
    public class Phone
    {
        public void Dial()
        {
            Console.WirteLine("Phone.Dial");
        }
    }
}

namespace CompanyB
{
    public class BetterPhone : CompanyA.Phone
    {
        public void Dial()
        {
            Console.WriteLine("BetterPhone.Dial");
            EstablishConnection();
            base.Dial();
        }
        
        protected virtual void EstablishConnection()
        {
            Console.WriteLine("BetterPhone.EstablishConnection");
            //在这里执行连接操作
        }
    }
}
```

显然，这么做会导致继承自Phone的Dial()方法被隐藏，编译器会因而警告你，同时她还会给你一个解决方案。

``` csharp
namespace CompanyB
{
    public class BetterPhone : CompanyA.Phone
    {
        //注意这里的new
        public new void Dial()
        {
            Console.WriteLine("BetterPhone.Dial");
            EstablishConnection();
            base.Dial();
        }
        
        protected virtual void EstablishConnection()
        {
            Console.WriteLine("BetterPhone.EstablishConnection");
            //在这里执行连接操作
        }
    }
}
```

如果要修改A，让Dial中调用EstablishConnection的方法。

``` csharp
//这里略过了一种 new的方法，具体请查看原书
namespace CompanyA
{
    public class Phone
    {
        public void Dial()
        {
            Console.WirteLine("Phone.Dial");
            EstablishConnection();
        }
        
        protected virtual void EstablishConnection()
        {
            Console.WriteLine("Phone.EstablishConnection");
            //在这里执行连接操作
        }
    }
}

namespace CompanyB
{
    public class BetterPhone : CompanyA.Phone
    {
        //注意这里override
        protected override void EstablishConnection()
        {
            Console.WriteLine("BetterPhone.EstablishConnection");
            //在这里执行连接操作
        }
    }
}
```

