---
title: 《CLRViaC#》第1章 CLR的执行模型
date: 2022-02-10 14:46:50
tags: [ C#, CLR]
categories: [ C#]
about:
description: "阅读笔记与总结，这本书的深度远高于我的理解范畴，因而笔记不免有所遗漏，如果有缺漏之处请查看原书。"
---

## 1.1 将源码编译成托管模块

CLR（Common Language Runitime）直译为公共语言运行时，由多种语言使用的"运行时"。CLR的核心功能可由面向CLR的所有语言来使用。这意味着可以使用多种不同的语言进行开发，使用最恰当的语言来进行任务，而不必过于担心他们彼此之间的交互问题，这些CLR会帮助我们处理。

支持CLR的各种语言编译器会将代码经过转换成为托管模块（managed module）再由他们交付给CLR进行下一步执行。

| 组成部分   | 说明                                                         |
| :--------- | ------------------------------------------------------------ |
| PE32/PE32+ | WindowsPE文件头，类似于CommonObjectFileFormat。PE32可以在windows32/64位上运行，而PE32+仅能在windows64位上运行。他还表示了文件类型，GUI，CUI，DLL，并包含一个时间标记来指出文件的生成时间。 |
| CLR头      | 包含使这个模块成为托管模块的信息，头中包含要求的CLR版本，Flag，托管模块入口方法的MethodDef元数据token以及模块的元数据、资源、强名称、一些标志等。 |
| 元数据     | 每个托管模块都包含元数据表。主要有两种表：一种表描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 |
| IL代码     | 编译器编译源代码生成的代码，运行时CLR将其编译成为CPU指令。   |

CLR之后经过本地代码编译器，会根据当前的CPU结构生成特定的代码，而每个面向CLR的编译器都会生成IL代码，有时也称呼她为托管代码(managed code)。除此之外，这些编译器还会向托管模块之中生成完整的元数据，元数据与IL代码文件关联，同时嵌入与代码相同的exe/dll当中，两者密不可分。

+ 元数据避免了编译时对原生C/C++头和库文件的需求，因为在实现类型/成员的IL代码文件之中，已包含有关引用类型/成员的全部信息。
+ Vs可以通过元数据读取类型之中有哪些方法，属性，事件和字段，帮忙编写程序。
+ CLR代码验证过程会使用元数据保证代码仅执行"类型安全"的操作。
+ 元数据允许序列化/反序列化。
+ 允许GC跟踪。

Miceosoft C++编译器默认生成包含非托管代码的EXE/DLL模块，并在运行时操作非托管数据，但如果需要也可以使用托管数据，并通过CLR集成。

## 1.2 将托管模块合并成程序集

CLR并不直接和模块工作，他和程序集工作。程序集是一个或者多个模块/资源文件的逻辑分组，在上述编译器完成工作之后，将模块整合为程序集。同时我们可以通过程序集对下属的文件进行管理，在需要的时刻对必要的文件进行处理。

同时，程序集中会包含与引用程序集相关的信息，使其可以自描述（self-describing），表面他的直接依赖代码，不必在注册表或者ADDS之中保存额外的信息。

## 1.3 加载公共语言运行时

最终生成的程序集可以是exe/DLL。但最终都是CLR来进行处理，显然，如果我们需要CLR来处理那么我们需要安装Microsoft的.Net Framework。

如果程序**只包含**类型安全的托管代码，那么代码在Windows32/64上都可以正常运转。但是如果使用了不安全的代码，或者需要面向某一种CPU架构的非托管代码进行互操作，就需要进行额外的步骤保证程序的正常运作。

VS->项目属性->目标平台

|    /platform开关     |  生成的托管模块  |      x86Windows      |      x64Windows      |    ARM Windows RT    |
| :------------------: | :--------------: | :------------------: | :------------------: | :------------------: |
|        anycpu        | PE32/任意CPU架构 | 作为32位应用程序运行 | 作为64位应用程序运行 | 作为32位应用程序运行 |
| anycpu32bitpreferred | PE32/任意CPU架构 | 作为32位应用程序运行 | 作为64位应用程序运行 | 作为32位应用程序运行 |
|         x86          |     PE32/x86     | 作为32位应用程序运行 | 作为64位应用程序运行 |        不运行        |
|         x64          |    PE32+/x64     |        不运行        | 作为64位应用程序运行 |        不运行        |
|         ARM          |     PE32/ARM     |        不运行        |        不运行        | 作为32位应用程序运行 |



## 1.4 执行程序集的代码

IL是与CPU无关的机器语言，相较于大多数的机器语言更加高级，可以访问操作对象类型，创建和初始化对象等等。高级语言通常只公开了CLR全部功能的一个子集。然而，IL汇编语言允许开发人员访问CLR的全部功能。所以，如果你选择的高级语言隐藏了你需要访问的CLR的功能，可以换用IL汇编语言或者提供了该功能的另一种语言来访问。

将IL转换成为本机CPU指令是CLR之中JIT（just-in-time）的责任。

JITCompiler 函数{

1. 在负责实现类型的程序集的元数据中查找被调用的方法
2. 从元数据中获取该方法的IL
3. 分配内存块
4. 将IL编译成本机CPU指令，然后将这些本机代码存储到步骤3分配的内存当中
5. 在Type表中修改与方法对应的条目，是他指向步骤3分配的内存块
6. 跳转到内存块中的本机代码

}

方法第二次执行就会略过JIT的步骤，直接在本机内查找已经编译完成的代码进行执行。因而方法仅在首次调用时才会有一定的性能损失，之后所有代码安装本机代码的形式运行。

JIT将本机CPU指令存储到动态内存之中，意味着程序终止，编译好的代码就会被丢失，下次启动就会重新编译。

但值得注意的是，JIT并不一定会拖慢速度，CLR会为JIT生成的代码进行优化。

| 编译器开关                          | C#IL代码指令 | JIT本机代码质量 |
| ----------------------------------- | ------------ | --------------- |
| /optimize- /debug(默认)             | 未优化       | 优化            |
| /optimize- /debug(+/full/pdbonly)   | 未优化       | 未优化          |
| /optimize+ /debug(-/+/full/pdbonly) | 优化         | 优化            |

另外可以考虑使用System.Runtime.ProfileOptimization类。该类会导致CLR检查程序运行时哪些方法会被JIT编译，结果会被记录到一个文件，程序再次启动时，如果是在多CPU机器上运行，就用其他线程并发编译这些方法。

### 1.4.2 不安全的代码

MicrosoftC#编译器也允许开发人员编写unsafe代码，他们通常允许直接操作内存地址，并可操作这些地址处的字节。 但显然直接操作地址的行为有极大的风险，因而包含unsafe代码的所有方法都需要使用unsafe标记。C#编译器要求使用/unsafe编译器开关来编译源代码。

当JIT编译器编译一个unsafe方法时，会检查该方法所在的程序集是否被授予了System.Security.Permissions.SecurityPermission权限，System.Security.Permissions.SecurityPermissionFlag的Skip标志是否设置。

如果上述条件缺一，CLR会阻止编译并抛出异常，禁止方法乃至整个程序进行。

从本地计算机或者从网络共享加载的程序集默认拥有完全信任，但从Internet下载的程序集不会被赋予执行不安全代码的权限。

## 1.6 Framework类库

.NET Framework包含Framework类库（Framework Class Library,FCL）。FCL是一组DLL程序集的统称，包含数千个类型定义。

+ Web服务
+ 基于HTML的Web窗体/MVC应用程序
+ “富”WindowsGUI应用程序
+ Windows控制台应用程序
+ Windows服务
+ 数据库存储过程
+ 组件库

部分常用FCL命名空间

| 命名空间                       | 内容说明                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| System                         | 包含每个应用程序都要使用的基本类型                           |
| System.Data                    | 包含用于和数据库通信以及处理数据的类型                       |
| System.IO                      | 包含用于执行流I/O以及浏览目录/文件的类型                     |
| System.Net                     | 包含进行低级网络通信，并与一些常用Internet协议协作的类型     |
| System.Runtime.InteropServices | 包含允许托管代码访问非托管代码访问非托管操作系统平台功能(比如COM组件以及Win32或定制DLL之中的函数)类型 |
| System.Security                | 包含用于保护数据和资源的类型                                 |
| System.Text                    | 包含处理各种编码文本的类型                                   |
| System.Threading               | 包含用于异步操作和同步资源访问的类型                         |
| System.Xml                     | 包含用于处理各种XML框架和数据的类型                          |

## 1.7 通用类型系统

CLR一切都围绕类型展开，通过类型，用一种编程语言写的代码能与另一种编程语言写的代码进行沟通。由于类型是CLR的根本，所以microsoft制定了一套标准用于规范，这就是通用类型系统（Common Type System）

CTS规定一个类型可以包含一个或者多个成员

+ 字段Field
+ 方法Method
+ 属性Property
+ 事件Event

CTS还指定了类型的可见性，类型继承，虚方法，对象生存等等规则。事实上并不需要刻意去学习CTS的语言本身，因为我们所选择的语言会通过自己的方式会公布自己的规则，然后通过特有的语言转到IL。

但是CTS的行为却需要我们知晓，举例而言CTS规定只可以单继承，而C++如果进行多继承就会报错。

## 1.8 公共语言规范

CLR集成的语言是一种直接交互，在一种语言之中创建的对象在另一种语言之中依然有效。但不同语言之间存在极大差异，为了找到这些差异之间的共同点，公共语言规范因运而生（Common Language Specification, CLS）。

显然，CLS所定义的范畴远低于CLR/CTS，他用于对外交互，因而有很多功能并不能在CLS范畴完成。

[assembly:CLSCompliant(true)]这个特性应用于程序集，会告诉编译器检测其中的公开类型，判断是否存在任何不合适的构造。

## 1.9 与非托管代码的互操作性

+ 托管代码能够调用DLL中的非托管代码
+ 托管代码可以使用现有的COM组件
+ 非托管代码可以使用托管类型（服务器）
